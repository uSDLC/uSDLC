<div id="pageTitle" class="editable" uuid="877221a7-b497-4c05-9e35-e60d2bab8fec">
 <h1> Session Environment</h1>
 <h2> For a conversation, both sides need to remember what was said</h2>
</div>
<div id="s1" class="editable section">
 <p> HTTP is a connectionless protocol. This means that every exchange between browser and server is new. This is fine for a simple web site where every exchange is &quot;give me ...&quot; and &quot;here it is&quot;. This is not enough for a full conversation where we need to know who we are talking to (authentication) and what we are talking about (session).</p>
</div>
<div id="s2" class="editable section synopsis">
 <p> There are 3 ways to keep session.</p>
 <ol>
  <li> Cookies in the browser cache. This is an array of name/value pairs packed into a single string passed back in the header for every request. </li>
  <li> In a map on the server, keyed by a single cookie. This is simple and efficient, but does not work in the cloud or any environment with multiple servers servicing a conversation. </li>
  <li> In the database. This works everywhere at the expenses of efficiency. It also suffers from being too persistent. Even when a session is over, it's remnants will live in the database until cleaned up. This is the approach used for Appengine and is also the standard method used by .NET. </li>
 </ol>
 <p> uSDLC has an Environment class that supports methods 2 and 3. Method 2 used for the conversational session information on single server installations. The persistence in method 3 is for longer term session data (usually related to the logged in user) and for cloud environments such as appengine.</p>
 <p> If your code only needs a single piece of session data, Environment provides a simple shortcut. Use <a class="usdlc" href="EnvironmentDataAccess.groovy" id="s2a0" action="runnable"><strong><em>Environment.name</em></strong></a> to set or retrieve data that will last as long as the exchange session with the browser exists.</p>
</div>
<div id="s3" class="editable section synopsis">
 <p> For code that requires access to more than one piece of session data it is effective to gain a reference to the <a class="usdlc" href="SessionObject.groovy" id="s3a0" action="runnable">session object</a> and use that.</p>
</div>
<div id="s6" class="editable section synopsis">
 <p> At each exchange the <a class="usdlc" href="EnvironmentIsSeeded" id="s6a0" action="page">environment is seeded</a>:</p>
 <ul>
  <li> header: a map of name/value pairs from the HTTP header </li>
  <li> path: The url (based on the uSDLC starting point) used to make this request </li>
  <li> script: The name of the script request if such it is. </li>
  <li> here: The storage path that relates to this url - from the starting directory (Store.base()) </li>
  <li> clientType: Client extension (as in js, html, css, etc) </li>
  <li> query: map of name value pairs from the URL query string (a=b&amp;c=d) </li>
  <li> cookies: map of name value pairs referency browser cookies </li>
  <li> userId: reference to the logged in user or 'anon' otherwise </li>
  <li> doc: a builder for writing return data - based on client type. There are builders for HTML, Javascript and text. </li>
  <li> db: a reference to the uSDLC database connection (only made if needed). </li>
  <li> finaliser: map of list of closures to call when the map key owner wants to finalise functionality. There are finalisers for exchanges and sessions. </li>
 </ul>
</div>
<div id="s4" class="editable section">
 <p> A session is created when the browser first requests a conversation with the uSDLC server. A session key is generated and saved in a cookie. At the start of each exchange the cookie is used to retrieve any session data and connect it to the thread name for the thread servicing this exchange. Rather than add data to the session for every module that has need of session persistence, uSDLC provides the concept of a reference.</p>
 <p> The Config file (web.groovy) contains a map called <a class="usdlc" href="EnvironmentRegister.groovy" id="s4a0" action="runnable"><em>environmentRegister</em></a>. It is keyed by session property name with a string value of the qualified class name. The first attempt to access data by this name will create an instance of the qualified class and call a method <em>reference&nbsp;</em>passing it the property name. Whatever this method returns is saved in the environment for later use - so it typically returns the instance of the qualified class (this). Use registration when you don't want to needlessly load the class until it is required. The Database class is an example when used to access the uSDLC persistent store.</p>
</div>
<div id="s5" class="editable section synopsis">
 <p> If a class has already been instantiated (as in a uSDLC actor), the ensure method is a more lightweight and simpler solution. During creation, <a action="runnable" class="usdlc" href="Ensure.groovy" id="s5a0">ensure</a> can be passed a closure to use if property instantiation is needed.</p>
</div>
<div id="s7" class="editable section">
 <p> Data has a life. Connections tend to hog resources or go stale unless they are released when they are no longer needed. There is a map of maps in the environment called <a href="Finaliser.groovy" id="s7a0" class="usdlc" action="runnable">finaliser</a> to support the end of life needs. &nbsp;Currently finaliser.session and finaliser.exchange walk through a list of provided closures when they close themselves. Normally database connections will close at the end of every exchange. By using&nbsp;new <em>Gsql(lifetime : &quot;session&quot;)</em> they will not be closed as long as the session remains valid.</p>
</div>
<div id="s8" class="editable section">
 <p> A session also has a lifetime with states for open, sleeping and closed. A session enters the sleeping state by calling all the finalisers registered. The assumption here is that if the session is active again these units can reopen their connections. Once a session is closed, all session data is removed.</p>
</div>
