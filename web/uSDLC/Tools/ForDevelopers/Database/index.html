<div id="pageTitle" class="editable" uuid="e17f25e8-e5b4-4792-9011-342c138e0d0c">
 <h1> Database</h1> 
 <h2> When persistence is a must</h2> 
</div> 
<div id="s1" class="editable section" contextmenu="section">
 <p> uSDLC used embedded H2 as an SQL complient persistence engine. It uses databases for task management, to support migration and as a convenient local engine for gsql scripts (See Actors).</p> 
</div> 
<div id="s2" class="editable section synopsis" contextmenu="section">
 <p> uSDLC maintains a connection to an internal database by the same name. It is available using <em>Environment.db</em> - being one conneciton per user session. You can, for example, access <a class="usdlc" href="ThePrioritiesTable.groovy" id="s2a0" action="runnable">the priorities table</a>: </p> 
</div> 
<div id="s3" class="editable section running synopsis" contextmenu="section">
 <p> The general database access documentation is available for the SQL actor. If using a gsql actor you can set the <a href="USDLCAsTheDefault.gsql" id="s3a0" class="usdlc" action="runnable">uSDLC as the default</a> database for operations.</p> 
</div> 
<div id="s5" class="editable section synopsis" contextmenu="section">
 <h1> Versioning</h1> 
 <p> uSDLC adds versioning and data migration to the basic SQL library. While it is primarily for uSDLC, it can also be used for the system under development if you so wish. For uSDLC there is a static convenience <a action="runnable" class="usdlc" href="Version.gsql" id="s5a0">version</a> method on Database. The prime data tier class for a component will call this method to set a static version number - and as a side-effect, migrate data from the existing database to the new version.</p> 
</div> 
<div id="s6" class="editable section" contextmenu="section">
 <h1> Operational Version</h1> 
 <p> The versioning system needs to know the operational version expected by the code. You can hard-code this or...</p> 
 <p> uSDLC scans all files in WEB-INF with a template of <em>*TableVersions.properties</em>. The core uSDLC system uses <em>usdlcTableVersions.properties</em>.</p> 
</div> 
<div id="s7" class="editable section" contextmenu="section">
 <h2> Creating Operational Version</h2> 
 <p> The uSDLC&nbsp;version file is generated by an ant task during build using the migration scripts to find the most recent version expected. It looks for any file of the form nnnn.vvv.sql (when nnn is any name and vvv is a 3 digit version number is the source base. You can do the same by using Database.migrationScan().</p> 
</div> 
<div id="s8" class="editable section" contextmenu="section">
 <h1> Database Migration</h1> 
 <p> The versioning above is there to support an organised data migration strategy. A version is related to a module that is the prime access &nbsp;a cohesive group of database tables. By example, uSDLC has groups called Core and Tasks. For tasks, **/db/Tasks.001.sql will be created to create the needed tables and see then with any base data. If after a general release I need to add a table and add a column to another, then I will create **/db/Tasks.002.sql. When usdlc.jar is build, usdlc.TableVersions.properties to reside inside the jar file will have Tasks with a version of 002. The first time a page is accessed on an upgraded system, **/db/Tasks.002.sql will be run.</p> 
 <p> The effect is cumulative. If a system is upgraded from version 001 to 005, the 4 upgrade scripts will be run one after the other.</p> 
 <p> While I used sql files by default, any actor can be used - so the migration can be gsql, groovy or even java.</p> 
</div> 
<div id="s4" class="editable section" contextmenu="section"></div>