<div id="pageTitle" class="editable" uuid="34a26382-672d-4cad-8829-b2aaa48d50be">
 <h1> A Case Study</h1> 
 <h2> Design by Example</h2> 
</div> 
<div id="s1" class="editable section" contextmenu="section">
 <p> The only way to ratify new concepts is to implement them. To this end I have documented a green-field application called &quot;<em>Bundy Clock</em>&quot; to provide time recording and reporting services for contractors who charge on an hourly rate.</p> 
</div>
<div id="s4" class="editable section" contextmenu="section">
 <p> This chapter is a blow-by-blow description for creating the project BundyClock. To be able to review the result, check it out from the <a href="https://github.com/paulmarrington/BundyClock" id="s4a0">BundyClock GitHub Repo</a>.</p> 
</div>
<div id="s6" class="editable section synopsis" contextmenu="section">
 <h3> How to start - the chicken or the egg</h3> 
 <p> First, let's get the metaphore straight. The egg came first. It was laid my an almost-chicken. Back to business...</p> 
 <p> I will be using &quot;<a action="page" class="usdlc" href="/uSDLC/Appendices/DesignByDecomposition" id="s6a0"><em>Design by Decomposition</em></a>&quot;, but first we have to decide on a project. The solution is simple - create the egg (<em>The Vision</em>) and place it into the project once it has been created.</p> 
</div>
<div id="s7" class="editable section synopsis" contextmenu="section">
 <h3> Book Structure</h3> 
 <p> Next I take the document framework from&nbsp;&quot;<em>The Rule of Threes</em>&quot; in&nbsp;&quot;<a class="usdlc" href="/uSDLC/Appendices/DesignByDecomposition" id="s6a0" action="page"><em>Design by Decomposition</em></a>&quot;.</p> 
</div>
<div id="s8" class="editable section" contextmenu="section">
 <h3> The Environment</h3> 
 <p> Before we can write code or implement data structures, we need a working development environment. In true agile fashion, we need only implement the environmental features we need to start - the server and database components.</p> 
 <p> Since the choice of Django as an application server was made as part of the vision, it is possible to fill in the relavent portions under Environment / Frameworks.</p> 
 <p> I have documented the one-off tasks of installing Python, Django and IntelliJ as I do the work. It does not take long and helps when I will need to create a new environment later.</p> 
</div>
<div id="s9" class="editable section" contextmenu="section">
 <h3> Back to Vision</h3> 
 <p> Do a brain dump of all the 'things' you have been thinking that the application can accomplish. Make it as bullet points a single section in The Vision. uSDLC can break up the points into sections and help you move them to their rightful place in the structure.</p> 
 <p> Because I was thinking bottom-up at this point - about the event model - I was able to put my bullet list directly into Requirements. It looked like:</p> 
 <p> &nbsp;</p> 
 <ul> 
  <li> Event records have user, notes, date and project</li> 
  <li> A project is for the user and references a client</li> 
  <li> User only select client/project when they change</li> 
  <li> All data is entered by http get</li> 
  <li> http get to add event</li> 
  <li> http get to change project</li> 
  <li> http get to change client</li> 
  <li> Once a user registers they are assigned a unique key for http get</li> 
 </ul> 
 <p> Compare that to the requirements page in the vision. You will find the items in their refactored groups. I did this refactoring much later.</p> 
</div>
<div id="s10" class="editable section" contextmenu="section">
 <h3> Some Detail</h3> 
 <p> Personally I design better in code than drawings, so given the bullet list above I am able to go to Design/Data Access/Event Store and define how the core data will be accessed.</p> 
 <p> Firstly this encourages me to decompose the bullet list above into database models, http updates and authentication. For the moment I keep the 3 tables in the Requirements page.</p> 
 <p> Notice how the first section documents how I created the events app using the Django manage script. Because I am using a Django DSL I can run this again and it won't do anything (app already exists).</p> 
 <p> Note that the first section is a Django script that clears and updates the database tables for the application. In this way when the page is run on an existing or new development environment it will clean everything up and create the tables to match. The sql clear statement will not activate in production.</p> 
</div>
<div id="s12" class="editable section" contextmenu="section">
 <h3> More Detail</h3> 
 <p> We are on a roll and our bullet points above indicate the next section that can easily be approached - event access via http. Our request don't have to be incredibly secure, so all we need is a token to separate the data.</p> 
</div>
<div id="s11" class="editable section" contextmenu="section">
 <h3> Discovery</h3> 
 <p> To access the information related to a user we have decided on a token. Since the auth model does not have a convenient token, we are going to have to generate and save one. The first time a user logs in they are allocated a uuid that can be used for unsecured http get calls.</p> 
 <p> Simple to implement in the data model, but like all discoveries it has 'implications'. &nbsp;Back to The &quot;<em>Vision / Requirements</em>&quot; to add bullet points for token management.</p> 
 <p> &nbsp;</p> 
 <ul> 
  <li> Once a user registers they are assigned a unique token for http get</li> 
  <li> generate and save token the first time a logged in user askes for it</li> 
  <li> create a page of http get links including the token for the user to save and use</li> 
  <li> mobile app will require authentication to retrieve and save user token</li> 
  <li> Web app is independant of event updates as it just post to a separate address with the token</li> 
 </ul> 
</div>
<div id="s14" class="editable section" contextmenu="section">
 <h3> Who Am I?</h3> 
 <p> Before we can return to the http get interface we need to implement the basics so that we can generate and access the token. So, the first thing we need is a log-in screen. Fortunately Django does most of the work for us. In the traditions of D3D, you can follow the story in &quot;<em>BundyClock / Design / Data Acess / Authentication</em>&quot;.</p> 
 <p> Why Data Acess instead of User Interfaces? Because authentication is by HTTP post so it can be used by any and all user interfaces.</p> 
 <p> So, the challenge is simply defined - to be able to log in and out repeatedly. &nbsp;Once that is successful, create a token, save it and display on request.</p> 
</div>
<div id="s13" class="editable section" contextmenu="section">
 <h3> Moving On</h3> 
 <p> Now that we have recorded details on the discovery we can comfortably return the the http event update. This is under &quot;<em>Design / Data Acess&quot;</em> as before.</p> 
</div>
<div id="s5" class="editable section" contextmenu="section"></div> 
<div id="s2" class="editable section footer synopsis" contextmenu="section"> 
 <div> 
  <a class="usdlc" href=".." id="s2a3" action="page">Parent</a> - 
  <a class="usdlc" href="Setup.groovy" id="s2a0" action="runnable">Setup</a> - 
  <a class="usdlc" href="Cleanup.groovy" id="s2a0" action="runnable">Cleanup</a> 
 </div> 
</div>