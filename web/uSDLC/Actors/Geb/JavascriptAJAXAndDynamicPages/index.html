<div id="pageTitle" class="editable"><h1>
	Javascript, AJAX and Dynamic Pages</h1>

	<h2>
		Web 2.0 - eat your heart out</h2>
</div>

<div id="s1" class="editable section" contextmenu="section"><p>
	This section discusses how to deal with some of the challenges in testing and/or automating modern web
	applications.</p>
</div>
<div id="s3" class="editable section synopsis" contextmenu="section"><p>
	<a href="Setup.geb" id="s3a0" class="usdlc" action="runnable">Setup</a></p>
</div>
<div id="s2" class="editable section synopsis" contextmenu="section"><p>
	&nbsp;</p>

	<h1>
		The "js" object</h1>

	<p>
		The browser instance exposes a "js" object that provides support for working with Javascript over and above what
		WebDriver provides. It's important to understand how WebDriver does handle Javascript, which is through a
		driver's implementation of&nbsp;<a href="http://geb.codehaus.org/latest/manual/javascriptexecutor" id="s2a0">JavascriptExecutor</a>'s&nbsp;<a
			href="http://geb.codehaus.org/latest/manual/execscript" id="s2a1">executeScript()</a>&nbsp;method.</p>
	<blockquote>
		<p>
			Before reading further, it's&nbsp;<strong>strongly</strong>&nbsp;recommended to read the description of&nbsp;<a
				href="http://geb.codehaus.org/latest/manual/execscript" id="s2a2" style="text-decoration: none; "><code>executeScript()</code></a>&nbsp;in
			order to understand how type conversion works between the two worlds.</p>
	</blockquote>
	<blockquote>
		<p>
			The JavascriptExecutor interface does not define any contract in regards to the driver's responsibility when
			there is some issue executing Javascript. All drivers however throw some kind of exception when this
			happens.</p>
	</blockquote>
	<p>
		You can execute Javascript like you would with straight <a class="usdlc" href="WebDriver.geb" id="s2a3"
		                                                           action="runnable">WebDriver</a> using the driver
		instance via the browser…</p>
</div>
<div id="s4" class="editable section synopsis" contextmenu="section"><h2>
	Accessing Variables</h2>

	<p>
		Any global javascript variables inside the browser can be read as properties of the js object.</p>

	<p>
		Given the following page…</p>
<pre>    &lt;script type="text/javascript"&gt;
        var aVariable = 1;
    &lt;/script&gt;</pre>
	<hr>
	<hr>
	<p>
		We could access the <a class="usdlc" href="JavascriptVariable.geb" id="s4a0" action="runnable">javascript
		variable</a>&nbsp;"aVariable" with…</p>
</div>
<div id="s5" class="editable section synopsis" contextmenu="section"><h2>
	Calling Methods</h2>

	<p>
		Any global javascript functions can be called as methods on the js object.</p>

	<p>
		Given the following page…</p>
<pre>    &lt;script type="text/javascript"&gt;
        function addThem(a,b) {
            return a + b;
        }
    &lt;/script&gt;</pre>
	<p>
		We can call the addThem() function as below</p>
	<hr>
	<hr>
	<p>
		This also works from pages and modules.&nbsp;To <a href="Call.geb" id="s5a0" class="usdlc" action="runnable">call</a>
		nested methods, we use the same syntax as properties…</p>
</div>
<div id="s6" class="editable section synopsis" contextmenu="section"><h2>
	Executing Arbitrary Code</h2>

	<p>
		&nbsp;</p>

	<p>
		The js object also has an exec() method that can be used to run snippets of Javascript. It is identical to the
		JavascriptExecutor.executeScript() method, except that it takes its arguments in the other order…</p>
	<pre>assert js.exec(1, 2, "return arguments[0] + arguments[1];") == 3</pre>
	<p>
		You might be wondering why the order has been changed (i.e. the arguments go before the script). It makes
		writing <a href="MultilineJavascript.geb" id="s6a0" class="usdlc" action="runnable">multiline javascript</a>
		more convenient…</p>
</div>
<div id="s7" class="editable section synopsis running" contextmenu="section"><h1>
	Waiting</h1>

	<p>
		Geb provides some convenient methods for waiting for a certain condition to be true. This is useful for testing
		pages using AJAX or Timers.</p>
<pre>def waitFor(Closure condition)
def waitFor(Double timeoutSeconds, Closure condition)
def waitFor(Double timeoutSeconds, Double intervalSeconds, Closure condition)</pre>
	<p>
		These methods all do the same thing, except that they use default values for parameters that are not part of
		their signature. They are all available on browsers, pages and modules.</p>

	<p>
		The condition parameter is a closure that is periodically executed until it either returns a true value
		(according to the Groovy Truth) or a timeout is reached.</p>

	<p>
		The timeoutSeconds (default is 5) parameter defines the number of seconds to wait for the condition to become
		true. Note that this value is an approximation, it's used in conjuction with the intervalSeconds value to
		determine how many times the condition should be tested rather than doing any actual timing. Non whole numbers
		can be used for this value (e.g. 2.5)</p>

	<p>
		The intervalSeconds (default is 0.5) parameter defines the number of seconds to wait after testing the condition
		to test it again if it did not pass. Non whole numbers can be used for this value (e.g. 2.5). If this value is
		higher than the given timeoutSeconds, the condition will be tested once initially, then once again just before
		the timeout would occur.</p>
	<blockquote>
		<p>
			Notice that the 'theResultDiv' is declared required: false. This is almost always necessary when dealing
			with dynamic content as it's likely to not be present on the page when it is first accessed (see: section on
			required)</p>
	</blockquote>
	<p>
		Here is an example showing one way of using <a class="usdlc" href="WaitFor.geb" id="s7a0" action="runnable">waitFor</a>()
		to deal with the situation where clicking a button invokes an AJAX request that creates a new div on its
		completion.</p>
</div>
<div id="s8" class="editable section synopsis" contextmenu="section"><p>
	Because the browser instance also implements the <a href="BrowserWaitFor.geb" id="s8a0" class="usdlc"
	                                                    action="runnable">waitFor</a>() method, the above could have
	been written as below. It'.s generally preferable to put the waiting behind a method on the page or module so that
	it's reusable across tests</p>
</div>
<div id="s9" class="editable section" contextmenu="section"><h1>
	Alert and Confirm Dialogs</h1>

	<p>
		&nbsp;</p>

	<p>
		WebDriver currently does not handle the alert() and confirm() dialog windows. However, we can fake it through
		some Javascript magic as discussed on the WebDriver issue for this. Geb implements a workaround based on this
		solution for you. Note that this feature relies on making changes to the browser's window DOM object so may not
		work on all browsers on all platforms. At the time when WebDriver adds support for this functionality the
		underlying implementation of the following methods will change to use that which will presumably be more
		robust.</p>

	<p>
		The Geb methods prevent the browser from actually displaying the dialog, which is a good thing. This prevents
		the browser blocking while the dialog is displayed and causing your test to hang indefinitely.</p>
	<blockquote>
		<p>
			Unexpected alert() and confirm() calls can have strange results. This is due to the nature of how Geb
			handles this internally. If you are seeing strange results, you may want to run your tests/scripts against a
			real browser and watch what happens to make sure there aren't alert()s or confirm()s being called that you
			aren't expecting. To do this, you need to disable Geb's handling by changing your code to not use the
			methods below.</p>
	</blockquote>
</div>
<div id="s10" class="editable section synopsis" contextmenu="section"><h2>
	alert()</h2>

	<p>
		There are two methods that deal with alert() dialogs:</p>
<pre>String withAlert(Closure actions)
void withNoAlert(Closure actions)</pre>
	<p>
		The first method, withAlert(), is used to verify actions that will produce an alert() dialog. This method
		returns the alert message.&nbsp;If an alert dialog is not raised by the given “actions�? closure, an
		AssertionError will be thrown.</p>

	<p>
		The second method, withNoAlert(), is used to verify actions that will not produce an alert() dialog. If an alert
		dialog is raised by the given “actions�? closure, an AssertionError will be thrown.</p>
	<blockquote>
		<p>
			It's a good idea to use withNoAlert() when doing something that might raise an alert. If you don't, the
			browser is going to raise a real alert dialog and sit there waiting for someone to click it which means your
			test is going to hang. Using withNoAlert() prevents this.</p>
	</blockquote>
	<p>
		A side effect of the way that this is implemented is that we aren't able to definitively handle actions that
		cause the browser's actual page to change (e.g. clicking a link in the closure given to
		withAlert()/withNoAlert()). We can detect that the browser page did change, but we can't know if alert() did or
		did not get called before the page change. If a page change was detected the withAlert() method will return a
		literal true (whereas it would normally return the alert message), while the withNoAlert() will succeed.</p>

	<p>
		Given the following HTML…</p>

	<p>
		&lt;input type="button" name="showAlert" onclick="alert('Bang!');" /&gt;</p>
	<hr>
	<p>
		<input name="showAlert" onclick="alert('Bang!');" type="button"></p>
	<hr>
	<p>
		The <a class="usdlc" href="WithAlert.geb" id="s10a0" action="runnable">withAlert</a>() method is used like so…
	</p>
</div>
<div id="s11" class="editable section synopsis" contextmenu="section"><h2>
	confirm()</h2>

	<p>
		There are three methods that deal with confirm() dialogs:</p>
<pre>String withConfirm(boolean ok, Closure actions)
String withConfirm(Closure actions) // defaults 'ok' to true
void withNoConfirm(Closure actions)</pre>
	<p>
		The first method, withConfirm() (and its ‘ok’ defaulted relative), is used to verify actions that will produce
		an confirm() dialog. This method returns the confirmation message. The ok parameter controls whether the
		confirm() call should return true or false (i.e. the user has clicked the "OK"? or "Cancel" buttons).</p>

	<p>
		If a confirmation dialog is not raised by the given "actions" closure, an AssertionError will be thrown.</p>

	<p>
		The second method, withNoConfirm(), is used to verify actions that will not produce an confirm() dialog. If a
		confirmation dialog is raised by the given "actions" closure, an AssertionError will be thrown.</p>
	<blockquote>
		<p>
			It's a good idea to use withNoConfirm() when doing something that might raise a a confirmation. If you
			don't, the browser is going to raise a real confirmation dialog and sit there waiting for someone to click
			it which means your test is going to hang. Using withNoConfirm() prevents this.Given the following HTML…</p>
	</blockquote>
	<pre>&lt;input type="button" name="showConfirm" onclick="confirm('Do you like Geb?');" /&gt;</pre>
	<hr>
	<input type="button" name="showConfirm" onclick="confirm('Do you like Geb?');">
	<hr>
	<p>
		A side effect of the way that this is implemented is that we aren't able to definitively handle actions that
		cause the browser's actual page to change (e.g. clicking a link in the closure given to
		withConfirm()/withNoConfirm()). We can detect that the browser page did change, but we can't know if confirm()
		did or did not get called before the page change. If a page change was detected the withConfirm() method will
		return a literal true (whereas it would normally return the alert message), while the withNoConfirm() will
		succeed.</p>

	<p>
		Geb does not provide any support for prompt() due to it's infrequent and generally discouraged use.</p>

	<p>
		The <a class="usdlc" href="WithConfirm.geb" id="s11a0" action="runnable">withConfirm</a>() method is used like
		so…</p>
</div>
<div id="s12" class="editable section synopsis" contextmenu="section"><h1>
	jQuery Integration</h1>

	<p>
		Geb has special support for the jQuery javascript library. Navigator objects have a special adapter that makes
		calling jQuery methods against the underlying DOM elements simple. This is best explained by example.</p>

	<p>
		The jQuery integration only works when the pages you are working with include jQuery, Geb does not install it in
		the page for you.</p>

	<p>
		Consider the following page:</p>
<pre>    &lt;script type="text/javascript"&gt;
        $(function() {
            $("#a").mouseover(function() {
               $("b").show();
            });
        });
    &lt;/script&gt;
    &lt;div id="a"&gt;&lt;/div&gt;
    &lt;div id="b" style="display:none;"&gt;&lt;a href="http://geb.codehaus.org"&gt;Geb!&lt;/a&gt;&lt;/div&gt;</pre>
	<hr>
	<div id="a">
		&nbsp;</div>
	<div id="b">
		<a href="http://geb.codehaus.org" id="s12a0">Geb!</a></div>
	<hr>
	<p>
		We want to click the Geb link, but can't because it's hidden (WebDriver does not let you interact with hidden
		elements). The div containing the link (div "a") is only displayed when the mouse moves over div "a".</p>

	<p>
		The <a href="JQuery.geb" id="s12a1" class="usdlc" action="runnable">jQuery</a> library provides convenient
		methods for triggering browser events. We can use this to simulate the mouse being moved over the div "a".</p>
</div>
<div id="s13" class="editable section" contextmenu="section"><p>
	The jquery property of a navigator is conceptually equivalent to a jQuery object for all of the navigator's matched
	page elements.</p>

	<p>
		The methods can also take arguments…</p>
	<pre>$("#a").jquery.trigger('mouseover')</pre>
	<p>
		The same set of restricted types as allowed by WebDriver's executeScript() method are permitted here.</p>

	<p>
		All methods called on the jquery property always return the navigator instance that the jquery property is
		attached to.</p>

	<h2>
		Why?</h2>

	<p>
		This functionality was developed to make triggering mouse related events easier. Some applications are very
		sensitive to mouse events and triggering these events in an automated environment is a challenge. jQuery
		provides a good API for faking these events which makes for a good solution.<br>
		&nbsp;</p>
</div>





