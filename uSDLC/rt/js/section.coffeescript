$ ->
  usdlc.highlight = (colour, element) ->
    section = usdlc.getSection(element)
    if section
      if colour
        url = "url(/usdlc/rt/gradients/#{colour}-right.png)"
        section.css(
          backgroundImage : url
          backgroundPosition : -10
        )
      else
        section.css(backgroundImage : 'none')

  usdlc.green = (element) -> usdlc.highlight('green', element)
  ###
  Given an element (null for current focus), retrieve the section
  containing it.
  ###
  usdlc.getSection = (element) ->
    section = $(element or usdlc.inFocus)
    if not section.hasClass('editable')
      section = section.parents('div.editable')
    section
  ###
  Each paragraph is a focus element. Highlight it if clicked on or
  otherwise referenced to. inFocus used for first load after click.
  ###
  usdlc.setFocus = (element) ->
    section = usdlc.getSection(element)
    #if not section.hasClass('inFocus')
    usdlc.clearFocus()
    usdlc.inFocus = section
    usdlc.resetMenu()
    section.addClass('inFocus ui-widget-content')
    usdlc.contentTree.jstree('disable_hotkeys')
    $('#contentTree').removeClass('rounded pale-gray-box inFocus')
    usdlc.pageContentsSausages.sausage("setFocus", section)
    #usdlc.scrollTo section
    return section

  usdlc.clearFocus = ->
    if usdlc.inFocus
      usdlc.menuToTop()
      $('.inFocus').removeClass('inFocus ui-widget-content')
      usdlc.lastFocus = usdlc.inFocus
      usdlc.inFocus = null
    $('.inFocus').removeClass('inFocus ui-widget-content')
    usdlc.contentTree.jstree('enable_hotkeys')
    $('#contentTree').addClass('rounded pale-gray-box inFocus')

  usdlc.toggleFocus = ->
    if usdlc.inFocus
      usdlc.clearFocus()
    else
      usdlc.setFocus(usdlc.lastFocus || $('div.section:first'))

  usdlc.inFocus = null
  usdlc.lastFocus = null

  usdlc.nextSectionId = ->
    id = $('.section').length + 1
    id++ while ($('div#s' + id).length > 0)
    "s#{id}"

  usdlc.upFocus = ->
    return true unless usdlc.inFocus
    focus = usdlc.inFocus.prevAll('div.section:not(.deleted)').first()
    usdlc.setFocus(focus) if focus.length
    return false

  usdlc.downFocus = ->
    return true unless usdlc.inFocus
    focus = usdlc.inFocus.nextAll('div.section:not(.deleted)').first()
    if focus.size()
      usdlc.setFocus(focus)
    else
      usdlc.upFocus()
  ###
  Parse section title, subtitle, content, id and name (camel-case)
  ###
  usdlc.parseSection = (section) ->
    header = section.children().first('h1,h2,h3,h4,h5,h6')
    title = header.text()
    section.data =
      title : title
      subtitle : '...'
      content : header.nextAll()
      id : section.attr('id')
      name : usdlc.camelCase(title)
      header : header
      type: section.attr('type')
    if section.data.title.length > 32
      section.data.subtitle = section.data.title
      section.data.title = section.data.title.substring(0, 32)
      section.data.name = usdlc.camelCase(section.data.title)
    return section.data
  ###
  Process the HTML and save he section
  ###
  usdlc.saveSection = ($section) ->
    baseId = "#{$section.attr('id')}a"
    # Process links to see what they should do
    $('a', $section).removeAttr('action').each( (idx) ->
      self = $(this)
      targetId = baseId + idx
      self.attr('id', targetId) if not self.attr('id')
      href = self.attr('href')
      self.removeClass() # removes all classes so we can re-add
      return if not href
      lastChar = href.charAt(href.length - 1)
      endsInBang = (lastChar == '!')
      if endsInBang
        self.attr('action', 'download')
      else if href.indexOf(':') is -1 and href[0] isnt '#'
        self.addClass('usdlc')

        href = usdlc.camelCase(href)
        self.attr('href', href)
        endsInSlash = (lastChar == '/')
        isParent = (href is '..')
        isPage = endsInSlash or isParent or /^\w+$/.test(href)
        isHtml = isPage or
          (usdlc.mimeType(href).clientExt in ['html', 'gsp'])

        if isHtml
          self.attr('action', 'page')
        else
          if not self.attr('action')
            self.attr('action', 'runnable')
          self.addClass('sourceLink')
    )
    usdlc.checkForSynopsis($section)
    usdlc.savePage()
  ###
  Delete a section - by making it invisible
  ###
  usdlc.deleteSectionInFocus = ->
    if usdlc.inFocus
      toDelete = usdlc.inFocus
      usdlc.downFocus()
      toDelete.addClass('deleted')
      usdlc.savePage()
  ###
  restore a deleted section
  ###
  usdlc.undeleteSectionInFocus = ->
    if usdlc.inFocus
      usdlc.inFocus.removeClass('deleted showDeleted')
      usdlc.savePage()
  ###
  Toggle hiding and showing deleted sections
  ###
  usdlc.toggleShowDeleted = ->
    if $('.showDeleted').size()
      usdlc.downFocus() if usdlc.inFocus.hasClass('deleted')
      $('.deleted').removeClass('showDeleted')
    else
      $('.deleted').addClass('showDeleted')
  ###
  Load a page from disk and return the named section
  ###
  usdlc.loadSection = (name, page, action) ->
    split = name.split('#')
    if split.length > 1 then [page,name] = split
    first = page[0]
    if first isnt '~' and first isnt '/'
      page = "/uSDLC/Environment/Configuration/Templates/#{page}"

    $.get usdlc.serverActionUrl(page, 'raw'), (data) ->
      html = $("<div/>").html(data)
      action $("div.section h1:contains('#{name}')", html)

  # Anything that has focus can be edited.
  $('.editable').css('background-image', "none").live('click', (ev) ->
    usdlc.setFocus(ev.currentTarget)
    return true
  )
