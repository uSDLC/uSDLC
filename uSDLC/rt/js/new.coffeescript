$ ->
  ###
  Called by form to create a new section below the current one. It will create
  a new header link pointing to a child page based on the title.
  ###
  usdlc.newPageSection = (type) ->
    form = new usdlc.FormProcessor "#new#{type}Section"
    title = form.fieldMap['title']
    href = usdlc.camelCase(title)
    href = "#{type}_#{href}" if type isnt 'General'
    id = usdlc.nextSectionId()
    a = createLink href, 'page', "#{id}a0", title
    insertNewSection form, a, 1, id, type
  ###
  Called by form to create a new section below the current one. It will create
  a new header link referencing an instrumentation script based on the title.
  ###
  usdlc.newScenarioSection = ->
    newCodeSection 'Scenario', createBddLink
  usdlc.newInstrumentationSection = ->
    newCodeSection 'Instrumentation', createSingleLink
  usdlc.newReferenceSection = ->
    newCodeSection 'Reference', createSingleLink, 'reference'

  newCodeSection = (name, codeLinkCreator, type = 'runnable') ->
    form = new usdlc.FormProcessor "#new#{name}Section"
    [title, ext] = usdlc.titleExt form, 'title'
    href = "#{usdlc.camelCase(title)}.#{ext}"
    id = usdlc.nextSectionId()
    a = codeLinkCreator form, href, type, "#{id}a0", title
    insertNewSection form, a, 2, id, name


  usdlc.titleExt = (form, titleFieldName) ->
    title = form.fieldMap[titleFieldName]
    split = /^(.*)\.(\w+)$/.exec(title)
    if split
      title = split[1]
      ext = split[2]
      addActorType(ext)
    else
      ext = form.fieldMap['type']
    usdlc.setCookie('actorDefault', ext)
    return [title, ext]

  createBddLink = (form, href, action, id, title) ->
    $.get '/usdlc/support/usdlc/newScenario.groovy',
      scriptName: href
      page: usdlc.pageContentsURL
      given: form.fieldMap['Given']
      when: form.fieldMap['When']
      then: form.fieldMap['Then'], ->
        usdlc.absolutePageContents usdlc.pageContentsURL
    heading = $ '<span/>'
    heading.html title
    gwt = $ '<span/>', class: 'givenWhenThen'
    gwt.append(' &nbsp;(')
    gwt.append createLink "Given_#{href}", 'runnable', "#{id}g", 'G'
    gwt.append createLink "When_#{href}", 'runnable', "#{id}w", 'W'
    gwt.append createLink "Then_#{href}", 'runnable', "#{id}t", 'T'
    gwt.append(')')
    heading.append gwt
    return heading

  createSingleLink = (form, href, action, id, title) ->
    createLink href, action, id, title
  ###
  Called by form to create a new section below the current one. It will create
  a new header link pointing to a child page based on the title.
  ###
  usdlc.newGeneralSection = (type) ->
    form = new usdlc.FormProcessor "#new#{type}Section"
    title = form.fieldMap['title']
    id = usdlc.nextSectionId()
    heading = $ '<span/>'
    heading.html title
    insertNewSection form, heading, 2, id, type
    usdlc.editSectionInFocus()
  ###
  This is where the work is done...
  ###
  createLink = (href, action, id, title) ->
    a = $ '<a/>',
      href: href
      action: action
      id: id
      class: 'usdlc'
    a.html title
    return a
  ###
  Create a new section given a template
  ###
  usdlc.sectionTemplate = (name, page = 'Sections') ->
    usdlc.loadSection name, page, (h1) ->
      section = usdlc.newSection(name)
      section.append h1.nextAll()
      section.insertAfter(usdlc.inFocus)
      usdlc.setFocus(section)
      usdlc.editSectionInFocus()

  insertNewSection = (form, heading, level, id, type) ->
    if usdlc.inFocus
      notes = form.fieldMap.notes

      section = usdlc.newSection type, id
      h1 = $ "<h#{level}/>"
      h1.append heading

      section.append h1
      if notes then section.append $ "<p>#{notes}</p>"
      section.insertAfter(usdlc.inFocus)
      usdlc.setFocus(section)
      usdlc.savePage()
    else
      usdlc.alert "Select Section First"
    usdlc.closeDialog() if not form.fieldMap.KeepOpen
  ###
  Creates basic new section code.
  ###
  usdlc.newSection = (type, id = usdlc.nextSectionId()) ->
    div = $ "<div/>",
      id : id
      'class' : 'editable section synopsis'
    div.append "<div class='sectionType'>#{type}</div>"
    return div

  usdlc.loadActorTypes = (select) ->
    actorTypes = (usdlc.cookie('actorTypes') || 'coffee').split(',')
    $.each actorTypes, (index, value) ->
      option = $ '<option/>',
        value: value
      option.text value
      select.append option
    select.val usdlc.cookie("actorDefault") || 'coffee'

  addActorType = (ext) ->
    actorTypes = (usdlc.cookie('actorTypes') || 'coffee').split(',')
    dups = (type for type in actorTypes when type == ext)
    if dups.length == 0
      actorTypes.push(ext)
      actorTypes.sort()
      usdlc.setCookie('actorTypes', actorTypes.toString())

  findType = (url) ->
    m = /(.*)\/(?:([a-zA-Z0-9]+)_)?([a-zA-Z0-9]+)(?:\/index\.html)?$/.exec url
    return m?[2] ? ''
    #return {path: m[1], type: m[2], name: m[3]}

  usdlc.newSectionForm = ->
    type = findType(usdlc.pageContentsURL)
    usdlc.form 'New Section:', (tabs) ->
      try
        li = $("a:contains('#{type}')", tabs).parent()
        next = li.next()
        li = next if next.size()
        href = $('a', li).attr('href')
        return href.substring(1)
      catch e
        return null

  usdlc.loadScenario = (input) ->
    return if not usdlc.inDialog(input)
    data =
      page: usdlc.pageContentsURL
      gwt: input.attr('name')
    $.get '/usdlc/support/usdlc/loadScenario.groovy', data, (rslt) ->
      input.bind "keydown", (event) ->
        # don't navigate away from the field on tab when selecting an item
        if event.keyCode is $.ui.keyCode.TAB
      	  if $(this).data("autocomplete").menu.active
      		  event.preventDefault()

      choices = eval rslt

      input.autocomplete
        minLength: 0
        autoFocus: true
        source: (request, response) ->
          # delegate back to autocomplete, but extract the last term
          last = request.term.split(/,\s*/).pop()
          response  $.ui.autocomplete.filter choices, last
        focus: -> return false # prevent value inserted on focus
        select: (event, ui) ->
          terms = this.value.split /,\s*/
          terms.pop() # remove the current input
          terms.push ui.item.value # add the selected item
				  # add placeholder to get the comma-and-space at the end
          terms.push ''
          this.value = terms.join ', '
          return false

  usdlc.loadProjects = (input) ->
    $.get '/usdlc/support/usdlc/loadUnassignedProjects.groovy', (rslt) ->
      choices = eval rslt
      input.autocomplete {source: choices, minLength: 0}

  usdlc.newProject = ->
    form = new usdlc.FormProcessor "#newProject"
    title = form.fieldMap['title']
    usdlc.closeDialog()
    $.get '/usdlc/support/usdlc/newProject.groovy', project:title, (rslt) ->
        usdlc.contentTree.jstree 'refresh', -1
