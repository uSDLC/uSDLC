$ ->
  class FormProcessor
    constructor: (selector) ->
      @form = $ selector
      @fieldMap = {}
      @altMap = {}
      @fieldList = []
      self = this
      $.each @form.serializeArray(), (i, field) =>
        @fieldMap[field.name] = field.value
        alt = $("[name=#{field.name}]", @form).attr('alt')
        if not alt
          if field.name[field.name.length - 1] == '_'
            alt = field.name.replace(/_/g, ' ')
          else
            alt = ''
        @altMap[field.name] = alt
        @fieldList.push field.name

    toHtml: ->
      html = []
      for name in @fieldList
        value = @fieldMap[name].replace(/\n/g, '<br>')
        if value.length
          label = @altMap[name]
          if label
            if label[0] is ' ' then html.push ''
            if label.length > 2 and label[0..1] == '::'
              html.push "::<b class='blue'>#{label.substring(2)}</b> #{value}"
            else
              html.push "<b class='blue'>#{label}</b> #{value}"
          else
            html.push value
      return '' if not html.length
      return "<div>#{html.join('<br/>')}</div>".replace(/<br.>::/, '&nbsp;')

  usdlc.FormProcessor = FormProcessor

  usdlc.autocomplete = (input, scriptPath, parameters = {}) ->
    inputElement.empty();
    $.get scriptPath, parameters, (response) ->
      if not parameters.multiple_select
        input.autocomplete
          source: eval response
          minLength: 1
        return
      # else multiple results allowed
      input.bind "keydown", (event) ->
        # don't navigate away from the field on tab when selecting an item
        if event.keyCode is $.ui.keyCode.TAB
          if $(this).data("autocomplete").menu.active
            event.preventDefault()
      choices = eval response
      input.autocomplete
        minLength: 1
        autoFocus: true
        source: (request, response) ->
          # delegate back to autocomplete, but extract the last term
          last = request.term.split(/,\s*/).pop()
          response  $.ui.autocomplete.filter choices, last
        focus: -> return false # prevent value inserted on focus
        select: (event, ui) ->
          terms = this.value.split /,\s*/
          terms.pop() # remove the current input
          terms.push ui.item.value # add the selected item
          # add placeholder to get the comma-and-space at the end
          terms.push ''
          this.value = terms.join ', '
          return false
      return
