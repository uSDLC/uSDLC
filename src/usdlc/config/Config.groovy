package usdlc.config

import java.lang.reflect.Method
import java.util.jar.Manifest
import usdlc.Dictionary
import usdlc.Store
import usdlc.actor.GroovyActor

/**
 * Wrapper for configSlurper so we can access multiple configuration files
 * easily. You will still need to restart the usdlc.server.servletengine.server
 * to pick up a new config.
 */

class Config {
	public static Map config
	static loaded
	/**
	 * Must be called early on by the server main program to initialise the
	 * configuration.
	 */
	static load(String environment, String baseDirectory, argList) {
		baseDir = baseDirectory
		slurper = new ConfigSlurper(environment)
		config = parseOptions('base')
		config.projects = [:]
		['webDriver', 'languages'].each { String scriptName ->
			config.merge(parseOptions(scriptName))
		}
		config.baseDirectory = baseDirectory
		Dictionary.commandLine(argList).each { String k, String v ->
			config[k] = v
		}
		// add home to source path so we can go app.blah
		config.srcPath << new File(config.home).absolutePath
		buildClassPath()
		config.classPathString = config.srcPath.join(';')
		config.tableVersions = loadTableVersions()
		runStartupScripts()
		loaded = true
	}

	private static Map parseOptions(String scriptName) {
		parse("/Options/Configuration/${scriptName}.groovy")
	}

	private static Map parse(String scriptPath) {
		def file = new File(baseDir, scriptPath)
		if (!file.exists()) return [:]
		def url = file.toURI().toURL()
		return slurper.parse(url)
	}
	/**
	 * Project specific data is collected the first time a
	 * project is accessed - by saving the bindings from running a script
	 * 'projectDir/usdlc/Config.groovy'. You can get the project data here
	 * or from any Store object with 'pd = store.project'.
	 *
	 * pd.name  Project name
	 * pd.home project home
	 */
	static Map project(String name) {
		if (!config.projects[name]) {
			Map pc
			switch (name.toLowerCase()) {
				case 'usdlc':
					pc = parse './uSDLC/Config.groovy'
					pc.home = '.'
					break
				case '':
					pc = parse './Config.groovy'
					pc.home = config.home;
					break
				default:
					def home = "$config.home/$name"
					pc = parse "$home/usdlc/Config.groovy"
					pc.home = home
					break
			}
			pc.name = Store.decamel(name.capitalize())
			config.projects[name] = pc
		}
		return config.projects[name]
	}

	static ConfigSlurper slurper
	static String baseDir

	static private buildClassPath() {
		// Add to the uSDLC classpath - so that compilers behave
		Method method = URLClassLoader.
				getDeclaredMethod('addURL', [URL] as Class[])
		method.accessible = true

		def systemClassLoader = ClassLoader.systemClassLoader
		config.classPath = []
		config.libPath.each { String path ->
			Store.base(path).dirs(~/.*\.jar/) { Store store ->
				method.invoke(systemClassLoader, [store.url] as Object[])
				config.classPath << store.url
			}
		}
		config.srcPath = config.srcPath.collect { String path -> toURL(path) }
		config.srcPath.each { URL url -> config.classPath << url }
		//config.dslClassPath = config.dslClassPath?.collect { toURL(it) }
		// ?: []

		System.getProperty('java.class.path').
				split(/${System.getProperty('java.path.separator')}/).each {
			config.classPath << new File(it).toURI().toURL()
		}
	}

	static private toURL(String path) {
		(path.indexOf(':') > 1) ? new URL(path) : Store.base(path).url
	}

	private static Properties loadTableVersions() {
		// auto-generated by and when building application jar
		def properties = new Properties()
		Store.base('rt').dirs(~/.*TableVersions.properties/) { Store store ->
			store.withInputStream { stream -> properties.load(stream) }
		}
		properties
	}

	static private runStartupScripts() {
		def actor = new GroovyActor()
		actor.backingScripts = config.startupScripts.collect { String name ->
			Store.base(name)
		}
		actor.run([:])
	}

	@Lazy static manifest = {
		def attributes = null
		try {
			Store store = Store.base('../META-INF/MANIFEST.MF')
			Manifest mf = new Manifest(store.url.openStream());
			attributes = mf.mainAttributes
		} catch (Exception e) { }
		attributes
	}()
	@Lazy static version = {
		Config.manifest?.getValue('Specification-Version') ?: 'Development'
	}()
}
